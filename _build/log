# dune fmt
# OCAMLPARAM: unset
# Shared cache: disabled
# Workspace root: /home/edo/Projects/99_problems
# Auto-detected concurrency: 4
$ /home/edo/.opam/default/bin/ocamlc.opt -config > /tmp/dune_00297f_output
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; for_host = None
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; ocaml_bin = External "/home/edo/.opam/default/bin"
#  ; ocaml = Ok External "/home/edo/.opam/default/bin/ocaml"
#  ; ocamlc = External "/home/edo/.opam/default/bin/ocamlc.opt"
#  ; ocamlopt = Ok External "/home/edo/.opam/default/bin/ocamlopt.opt"
#  ; ocamldep = Ok External "/home/edo/.opam/default/bin/ocamldep.opt"
#  ; ocamlmklib = Ok External "/home/edo/.opam/default/bin/ocamlmklib.opt"
#  ; env =
#      map
#        { "DUNE_OCAML_HARDCODED" :
#            "/home/edo/.opam/default/lib/ocaml:/home/edo/.opam/default/lib"
#        ; "DUNE_OCAML_STDLIB" : "/home/edo/.opam/default/lib/ocaml"
#        ; "DUNE_SOURCEROOT" : "/home/edo/Projects/99_problems"
#        ; "INSIDE_DUNE" : "/home/edo/Projects/99_problems/_build/default"
#        ; "OCAMLFIND_IGNORE_DUPS_IN" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib"
#        ; "OCAMLPATH" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib"
#        ; "OCAMLTOP_INCLUDE_PATH" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib/toplevel"
#        ; "OCAML_COLOR" : "always"
#        ; "OPAMCOLOR" : "always"
#        }
#  ; findlib_paths =
#      [ External "/home/edo/.opam/default/lib/ocaml"
#      ; External "/home/edo/.opam/default/lib"
#      ]
#  ; natdynlink_supported = true
#  ; supports_shared_libraries = true
#  ; ocaml_config =
#      { version = "5.0.0"
#      ; standard_library_default = "/home/edo/.opam/default/lib/ocaml"
#      ; standard_library = "/home/edo/.opam/default/lib/ocaml"
#      ; standard_runtime = "the_standard_runtime_variable_was_deleted"
#      ; ccomp_type = "cc"
#      ; c_compiler = "gcc"
#      ; ocamlc_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread"; "-fPIC" ]
#      ; ocamlc_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; ocamlopt_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread"; "-fPIC" ]
#      ; ocamlopt_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; bytecomp_c_compiler =
#          [ "gcc"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-fPIC"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; bytecomp_c_libraries = [ "-lm"; "-lpthread" ]
#      ; native_c_compiler =
#          [ "gcc"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-fPIC"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; native_c_libraries = [ "-lm"; "-lpthread" ]
#      ; native_pack_linker = [ "ld"; "-r"; "-o" ]
#      ; cc_profile = []
#      ; architecture = "amd64"
#      ; model = "default"
#      ; int_size = 63
#      ; word_size = 64
#      ; system = "linux"
#      ; asm = [ "as" ]
#      ; asm_cfi_supported = true
#      ; with_frame_pointers = false
#      ; ext_exe = ""
#      ; ext_obj = ".o"
#      ; ext_asm = ".s"
#      ; ext_lib = ".a"
#      ; ext_dll = ".so"
#      ; os_type = "Unix"
#      ; default_executable_name = "a.out"
#      ; systhread_supported = true
#      ; host = "x86_64-pc-linux-gnu"
#      ; target = "x86_64-pc-linux-gnu"
#      ; profiling = false
#      ; flambda = false
#      ; spacetime = false
#      ; safe_string = true
#      ; exec_magic_number = "Caml1999X032"
#      ; cmi_magic_number = "Caml1999I032"
#      ; cmo_magic_number = "Caml1999O032"
#      ; cma_magic_number = "Caml1999A032"
#      ; cmx_magic_number = "Caml1999Y032"
#      ; cmxa_magic_number = "Caml1999Z032"
#      ; ast_impl_magic_number = "Caml1999M032"
#      ; ast_intf_magic_number = "Caml1999N032"
#      ; cmxs_magic_number = "Caml1999D032"
#      ; cmt_magic_number = "Caml1999T032"
#      ; natdynlink_supported = true
#      ; supports_shared_libraries = true
#      ; windows_unicode = false
#      }
#  }
$ (cd _build/default && /home/edo/.opam/default/bin/ocamlformat --impl bin/main.ml) > _build/default/bin/.formatted/main.ml
$ /usr/bin/git --no-pager diff --no-index --color=always -u _build/default/bin/main.ml _build/default/bin/.formatted/main.ml
> diff --git a/_build/default/bin/main.ml b/_build/default/bin/.formatted/main.ml
> index d5cc2ee..2798b76 100644
> --- a/_build/default/bin/main.ml
> +++ b/_build/default/bin/.formatted/main.ml
> @@ -151,52 +151,47 @@ let split list n =
>  ;;
>  
>  (* Problem 18 *)
> -let slice list s e = fst (split (snd (split list s)) (e-s+1));;
> +let slice list s e = fst (split (snd (split list s)) (e - s + 1))
>  
>  (* Problem 19 *)
>  let rotate list n =
> -    let (l1, l2) = (split list n) in
> -    l2 @ l1
> +  let l1, l2 = split list n in
> +  l2 @ l1
>  ;;
>  
>  (* Problem 20 *)
>  let rec remove_at n list =
> -    if n = 0 then List.tl list
> -    else (List.hd list) :: (remove_at (n-1) (List.tl list))
> +  if n = 0 then List.tl list else List.hd list :: remove_at (n - 1) (List.tl list)
>  ;;
>  
>  (* Problem 21 *)
>  let rec insert_at x idx list =
> -    match list with
> -    | [] -> [x]
> -    | h::t ->
> -            if idx = 0 then x::list
> -            else h::(insert_at x (idx-1) t)
> +  match list with
> +  | [] -> [ x ]
> +  | h :: t -> if idx = 0 then x :: list else h :: insert_at x (idx - 1) t
>  ;;
>  
>  (* Problem 22 *)
>  let range s e =
> -    let rec aux s e =
> -        if s = e then [e] else s::(aux (s+1) e)
> -    in
> -    if s > e then List.rev (aux e s) else aux s e
> +  let rec aux s e = if s = e then [ e ] else s :: aux (s + 1) e in
> +  if s > e then List.rev (aux e s) else aux s e
>  ;;
>  
>  (* Problem 23 *)
>  let rand_select list n =
> -    let rec extract acc n = function
> -        | [] -> raise Not_found
> -        | h::t -> if n = 0 then (h, acc @ t) else extract (h::acc) (n-1) t
> -    in
> -    let extract_rand list =
> -        extract [] (Random.int (List.length list)) list
> -    in
> -    let rec aux n acc list =
> -        if n = 0 then acc
> -        else let picked, rest = extract_rand list in
> -        aux (n-1) (picked::acc) rest
> -    in
> -    aux (min n (List.length list)) [] list
> +  let rec extract acc n = function
> +    | [] -> raise Not_found
> +    | h :: t -> if n = 0 then h, acc @ t else extract (h :: acc) (n - 1) t
> +  in
> +  let extract_rand list = extract [] (Random.int (List.length list)) list in
> +  let rec aux n acc list =
> +    if n = 0
> +    then acc
> +    else (
> +      let picked, rest = extract_rand list in
> +      aux (n - 1) (picked :: acc) rest)
> +  in
> +  aux (min n (List.length list)) [] list
>  ;;
>  
>  (* Problem 24 *)
> @@ -206,17 +201,19 @@ let lotto_select n m = rand_select (range 1 m) n
>  
>  (* Problem 26 *)
>  let rec extract n list =
> -    if n <= 0 then [[]]
> -    else match list with
> +  if n <= 0
> +  then [ [] ]
> +  else (
> +    match list with
>      | [] -> []
> -    | h::t ->
> -            let with_h = List.map (fun l -> h :: l) (extract (n-1) t) in
> -            let without_h = extract n t in
> -            with_h @ without_h
> +    | h :: t ->
> +      let with_h = List.map (fun l -> h :: l) (extract (n - 1) t) in
> +      let without_h = extract n t in
> +      with_h @ without_h)
>  ;;
>  
>  (* Problem 27 *)
> -let group list sizes = ();;
> +let group list sizes = ()
>  
>  (* TESTING *)
>  let () =
> @@ -305,16 +302,38 @@ let () =
>        = ([ "a"; "b"; "c" ], [ "d"; "e"; "f"; "g"; "h"; "i"; "j" ]))
>    in
>    let _ = assert (split [ "a"; "b"; "c"; "d" ] 5 = ([ "a"; "b"; "c"; "d" ], [])) in
> -  let _ = assert (slice ["a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j"] 2 6 = ["c"; "d"; "e"; "f"; "g"]) in
> -  let _ = assert (rotate ["a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"] 3 = ["d"; "e"; "f"; "g"; "h"; "a"; "b"; "c"]) in
> -  let _ = assert (remove_at 1 ["a"; "b"; "c"; "d"] = ["a"; "c"; "d"]) in
> -  let _ = assert (remove_at 0 ["a"; "b"; "c"; "d"] = ["b"; "c"; "d"]) in
> -  let _ = assert (insert_at "alfa" 1 ["a"; "b"; "c"; "d"] = ["a"; "alfa"; "b"; "c"; "d"]) in
> -  let _ = assert (insert_at "alfa" 0 ["a"; "b"; "c"; "d"] = ["alfa"; "a"; "b"; "c"; "d"]) in
> -  let _ = assert (range 4 9 = [4; 5; 6; 7; 8; 9]) in
> -  let _ = assert (range 9 4 = [9; 8; 7; 6; 5; 4]) in
> -  let _ = (rand_select ["a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"] 3) in
> -  let _ = (lotto_select 2 3) in
> -  let _ = assert (extract 2 ["a"; "b"; "c"; "d"] = [["a"; "b"]; ["a"; "c"]; ["a"; "d"]; ["b"; "c"]; ["b"; "d"]; ["c"; "d"]]) in
> +  let _ =
> +    assert (
> +      slice [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j" ] 2 6
> +      = [ "c"; "d"; "e"; "f"; "g" ])
> +  in
> +  let _ =
> +    assert (
> +      rotate [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h" ] 3
> +      = [ "d"; "e"; "f"; "g"; "h"; "a"; "b"; "c" ])
> +  in
> +  let _ = assert (remove_at 1 [ "a"; "b"; "c"; "d" ] = [ "a"; "c"; "d" ]) in
> +  let _ = assert (remove_at 0 [ "a"; "b"; "c"; "d" ] = [ "b"; "c"; "d" ]) in
> +  let _ =
> +    assert (insert_at "alfa" 1 [ "a"; "b"; "c"; "d" ] = [ "a"; "alfa"; "b"; "c"; "d" ])
> +  in
> +  let _ =
> +    assert (insert_at "alfa" 0 [ "a"; "b"; "c"; "d" ] = [ "alfa"; "a"; "b"; "c"; "d" ])
> +  in
> +  let _ = assert (range 4 9 = [ 4; 5; 6; 7; 8; 9 ]) in
> +  let _ = assert (range 9 4 = [ 9; 8; 7; 6; 5; 4 ]) in
> +  let _ = rand_select [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h" ] 3 in
> +  let _ = lotto_select 2 3 in
> +  let _ =
> +    assert (
> +      extract 2 [ "a"; "b"; "c"; "d" ]
> +      = [ [ "a"; "b" ]
> +        ; [ "a"; "c" ]
> +        ; [ "a"; "d" ]
> +        ; [ "b"; "c" ]
> +        ; [ "b"; "d" ]
> +        ; [ "c"; "d" ]
> +        ])
> +  in
>    ()
>  ;;
[1]
