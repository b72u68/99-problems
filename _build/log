# dune fmt
# OCAMLPARAM: unset
# Shared cache: disabled
# Workspace root: /home/edo/Projects/99_problems
# Auto-detected concurrency: 4
$ /home/edo/.opam/default/bin/ocamlc.opt -config > /tmp/dune_967b89_output
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; for_host = None
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; ocaml_bin = External "/home/edo/.opam/default/bin"
#  ; ocaml = Ok External "/home/edo/.opam/default/bin/ocaml"
#  ; ocamlc = External "/home/edo/.opam/default/bin/ocamlc.opt"
#  ; ocamlopt = Ok External "/home/edo/.opam/default/bin/ocamlopt.opt"
#  ; ocamldep = Ok External "/home/edo/.opam/default/bin/ocamldep.opt"
#  ; ocamlmklib = Ok External "/home/edo/.opam/default/bin/ocamlmklib.opt"
#  ; env =
#      map
#        { "DUNE_OCAML_HARDCODED" :
#            "/home/edo/.opam/default/lib/ocaml:/home/edo/.opam/default/lib"
#        ; "DUNE_OCAML_STDLIB" : "/home/edo/.opam/default/lib/ocaml"
#        ; "DUNE_SOURCEROOT" : "/home/edo/Projects/99_problems"
#        ; "INSIDE_DUNE" : "/home/edo/Projects/99_problems/_build/default"
#        ; "OCAMLFIND_IGNORE_DUPS_IN" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib"
#        ; "OCAMLPATH" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib"
#        ; "OCAMLTOP_INCLUDE_PATH" :
#            "/home/edo/Projects/99_problems/_build/install/default/lib/toplevel"
#        ; "OCAML_COLOR" : "always"
#        ; "OPAMCOLOR" : "always"
#        }
#  ; findlib_paths =
#      [ External "/home/edo/.opam/default/lib/ocaml"
#      ; External "/home/edo/.opam/default/lib"
#      ]
#  ; natdynlink_supported = true
#  ; supports_shared_libraries = true
#  ; ocaml_config =
#      { version = "5.0.0"
#      ; standard_library_default = "/home/edo/.opam/default/lib/ocaml"
#      ; standard_library = "/home/edo/.opam/default/lib/ocaml"
#      ; standard_runtime = "the_standard_runtime_variable_was_deleted"
#      ; ccomp_type = "cc"
#      ; c_compiler = "gcc"
#      ; ocamlc_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread"; "-fPIC" ]
#      ; ocamlc_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; ocamlopt_cflags =
#          [ "-O2"; "-fno-strict-aliasing"; "-fwrapv"; "-pthread"; "-fPIC" ]
#      ; ocamlopt_cppflags = [ "-D_FILE_OFFSET_BITS=64" ]
#      ; bytecomp_c_compiler =
#          [ "gcc"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-fPIC"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; bytecomp_c_libraries = [ "-lm"; "-lpthread" ]
#      ; native_c_compiler =
#          [ "gcc"
#          ; "-O2"
#          ; "-fno-strict-aliasing"
#          ; "-fwrapv"
#          ; "-pthread"
#          ; "-fPIC"
#          ; "-D_FILE_OFFSET_BITS=64"
#          ]
#      ; native_c_libraries = [ "-lm"; "-lpthread" ]
#      ; native_pack_linker = [ "ld"; "-r"; "-o" ]
#      ; cc_profile = []
#      ; architecture = "amd64"
#      ; model = "default"
#      ; int_size = 63
#      ; word_size = 64
#      ; system = "linux"
#      ; asm = [ "as" ]
#      ; asm_cfi_supported = true
#      ; with_frame_pointers = false
#      ; ext_exe = ""
#      ; ext_obj = ".o"
#      ; ext_asm = ".s"
#      ; ext_lib = ".a"
#      ; ext_dll = ".so"
#      ; os_type = "Unix"
#      ; default_executable_name = "a.out"
#      ; systhread_supported = true
#      ; host = "x86_64-pc-linux-gnu"
#      ; target = "x86_64-pc-linux-gnu"
#      ; profiling = false
#      ; flambda = false
#      ; spacetime = false
#      ; safe_string = true
#      ; exec_magic_number = "Caml1999X032"
#      ; cmi_magic_number = "Caml1999I032"
#      ; cmo_magic_number = "Caml1999O032"
#      ; cma_magic_number = "Caml1999A032"
#      ; cmx_magic_number = "Caml1999Y032"
#      ; cmxa_magic_number = "Caml1999Z032"
#      ; ast_impl_magic_number = "Caml1999M032"
#      ; ast_intf_magic_number = "Caml1999N032"
#      ; cmxs_magic_number = "Caml1999D032"
#      ; cmt_magic_number = "Caml1999T032"
#      ; natdynlink_supported = true
#      ; supports_shared_libraries = true
#      ; windows_unicode = false
#      }
#  }
$ (cd _build/default && /home/edo/.opam/default/bin/ocamlformat --impl bin/main.ml) > _build/default/bin/.formatted/main.ml
$ /usr/bin/git --no-pager diff --no-index --color=always -u _build/default/bin/main.ml _build/default/bin/.formatted/main.ml
> diff --git a/_build/default/bin/main.ml b/_build/default/bin/.formatted/main.ml
> index 08f1fed..2178c5e 100644
> --- a/_build/default/bin/main.ml
> +++ b/_build/default/bin/.formatted/main.ml
> @@ -88,63 +88,67 @@ let encode list =
>  
>  (* Problem 11 *)
>  type 'a rle =
> -    | One of 'a
> -    | Many of int * 'a
> +  | One of 'a
> +  | Many of int * 'a
>  
>  let encode_rle list =
>    List.fold_right
>      (fun x acc ->
>        match acc with
> -      | [] -> [ (One x) ]
> -      | (One x') :: t -> if x' = x then (Many (2, x)) :: t else (One x) :: acc
> -      | (Many (c, x')) :: t -> if x' = x then (Many (c + 1, x)) :: t else (One x) :: acc)
> +      | [] -> [ One x ]
> +      | One x' :: t -> if x' = x then Many (2, x) :: t else One x :: acc
> +      | Many (c, x') :: t -> if x' = x then Many (c + 1, x) :: t else One x :: acc)
>      list
>      []
>  ;;
>  
>  (* Problem 12 *)
>  let rec decode = function
> -    | [] -> []
> -    | (One x)::t -> x::(decode t)
> -    | (Many (c, x))::t ->
> -            if c = 0 then decode t
> -            else x::(decode ((Many (c-1, x))::t))
> +  | [] -> []
> +  | One x :: t -> x :: decode t
> +  | Many (c, x) :: t -> if c = 0 then decode t else x :: decode (Many (c - 1, x) :: t)
> +;;
>  
>  (* Problem 13 *)
>  let encode_dir =
> -    let rle_count count x = if count = 1 then One x else Many (count, x) in
> -    let rec aux count = function
> -        | [] -> []
> -        | [h] -> [rle_count (count+1) h]
> -        | h1::(h2::_ as t) ->
> -                if h1 = h2 then aux (count+1) t
> -                else (rle_count (count+1) h1) :: (aux 0 t)
> -    in aux 0
> +  let rle_count count x = if count = 1 then One x else Many (count, x) in
> +  let rec aux count = function
> +    | [] -> []
> +    | [ h ] -> [ rle_count (count + 1) h ]
> +    | h1 :: (h2 :: _ as t) ->
> +      if h1 = h2 then aux (count + 1) t else rle_count (count + 1) h1 :: aux 0 t
> +  in
> +  aux 0
> +;;
>  
>  (* Problem 14 *)
> -let duplicate list = List.fold_right (fun x acc -> x::x::acc) list []
> +let duplicate list = List.fold_right (fun x acc -> x :: x :: acc) list []
>  
>  (* Problem 15 *)
>  let replicate list n =
> -    let rec rep x n = if n = 0 then [] else x::(rep x (n-1)) in
> -    List.fold_right (fun x acc -> (rep x n) @ acc) list []
> +  let rec rep x n = if n = 0 then [] else x :: rep x (n - 1) in
> +  List.fold_right (fun x acc -> rep x n @ acc) list []
> +;;
>  
>  (* Problem 16 *)
>  let drop list n =
> -    let rec aux = function
> -        | ([], _) -> []
> -        | (_::t, 1) -> aux (t, n)
> -        | (h::t, n) -> h::(aux (t, n-1))
> -    in aux (list, n)
> +  let rec aux = function
> +    | [], _ -> []
> +    | _ :: t, 1 -> aux (t, n)
> +    | h :: t, n -> h :: aux (t, n - 1)
> +  in
> +  aux (list, n)
> +;;
>  
>  (* Problem 17 *)
>  let split list n =
> -    let rec aux acc = function
> -        | ([], _) -> (acc, [])
> -        | (list, 0) -> (acc, list)
> -        | (h::t, n) -> aux (acc @ [h]) (t, n-1)
> -    in aux [] (list, n)
> -
> +  let rec aux acc = function
> +    | [], _ -> acc, []
> +    | list, 0 -> acc, list
> +    | h :: t, n -> aux (acc @ [ h ]) (t, n - 1)
> +  in
> +  aux [] (list, n)
> +;;
>  
>  (* TESTING *)
>  let () =
> @@ -197,15 +201,41 @@ let () =
>        encode [ "a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e" ]
>        = [ 4, "a"; 1, "b"; 2, "c"; 2, "a"; 1, "d"; 4, "e" ])
>    in
> -  let _ = assert (encode_rle ["a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e"] = [Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d";
> - Many (4, "e")]) in
> -  let _ = assert (decode [Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d"; Many (4, "e")] = ["a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e"]) in
> -  let _ = assert (encode_dir ["a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e"] = [Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d";
> - Many (4, "e")]) in
> -  let _ = assert (duplicate ["a"; "b"; "c"; "c"; "d"] = ["a"; "a"; "b"; "b"; "c"; "c"; "c"; "c"; "d"; "d"]) in
> -  let _ = assert (replicate ["a"; "b"; "c"] 3 = ["a"; "a"; "a"; "b"; "b"; "b"; "c"; "c"; "c"]) in
> -  let _ = assert (drop ["a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j"] 3 = ["a"; "b"; "d"; "e"; "g"; "h"; "j"]) in
> -  let _ = assert (split ["a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j"] 3 = (["a"; "b"; "c"], ["d"; "e"; "f"; "g"; "h"; "i"; "j"])) in
> -  let _ = assert (split ["a"; "b"; "c"; "d"] 5 = (["a"; "b"; "c"; "d"], [])) in
> +  let _ =
> +    assert (
> +      encode_rle [ "a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e" ]
> +      = [ Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d"; Many (4, "e") ])
> +  in
> +  let _ =
> +    assert (
> +      decode
> +        [ Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d"; Many (4, "e") ]
> +      = [ "a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e" ])
> +  in
> +  let _ =
> +    assert (
> +      encode_dir [ "a"; "a"; "a"; "a"; "b"; "c"; "c"; "a"; "a"; "d"; "e"; "e"; "e"; "e" ]
> +      = [ Many (4, "a"); One "b"; Many (2, "c"); Many (2, "a"); One "d"; Many (4, "e") ])
> +  in
> +  let _ =
> +    assert (
> +      duplicate [ "a"; "b"; "c"; "c"; "d" ]
> +      = [ "a"; "a"; "b"; "b"; "c"; "c"; "c"; "c"; "d"; "d" ])
> +  in
> +  let _ =
> +    assert (
> +      replicate [ "a"; "b"; "c" ] 3 = [ "a"; "a"; "a"; "b"; "b"; "b"; "c"; "c"; "c" ])
> +  in
> +  let _ =
> +    assert (
> +      drop [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j" ] 3
> +      = [ "a"; "b"; "d"; "e"; "g"; "h"; "j" ])
> +  in
> +  let _ =
> +    assert (
> +      split [ "a"; "b"; "c"; "d"; "e"; "f"; "g"; "h"; "i"; "j" ] 3
> +      = ([ "a"; "b"; "c" ], [ "d"; "e"; "f"; "g"; "h"; "i"; "j" ]))
> +  in
> +  let _ = assert (split [ "a"; "b"; "c"; "d" ] 5 = ([ "a"; "b"; "c"; "d" ], [])) in
>    ()
>  ;;
[1]
